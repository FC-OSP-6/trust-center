import p from "react";
import z from "react-dom/server";
function P(e, r) {
  const n = RegExp(e, "g");
  return (t) => {
    if (typeof t != "string")
      throw new TypeError(`expected an argument of type string, but got ${typeof t}`);
    return t.match(n) ? t.replace(n, r) : t;
  };
}
const R = P(/[A-Z]/, (e) => `-${e.toLowerCase()}`);
function A(e, r = R) {
  if (!e || typeof e != "object" || Array.isArray(e))
    throw new TypeError(`expected an argument of type object, but got ${typeof e}`);
  return Object.keys(e).map((n) => `${r(n)}: ${e[n]};`).join(`
`);
}
const L = {
  acceptCharset: "accept-charset",
  accessKey: "accesskey",
  allowFullScreen: "allowfullscreen",
  autoCapitalize: "autocapitalize",
  autoComplete: "autocomplete",
  autoCorrect: "autocorrect",
  autoFocus: "autofocus",
  autoPlay: "autoplay",
  autoSave: "autosave",
  cellPadding: "cellpadding",
  cellSpacing: "cellspacing",
  charSet: "charset",
  className: "class",
  classID: "classid",
  colSpan: "colspan",
  contentEditable: "contenteditable",
  contextMenu: "contextmenu",
  controlsList: "controlslist",
  crossOrigin: "crossorigin",
  dangerouslySetInnerHTML: "dangerouslysetinnerhtml",
  dateTime: "datetime",
  defaultChecked: "defaultchecked",
  defaultValue: "defaultvalue",
  disablePictureInPicture: "disablepictureinpicture",
  disableRemotePlayback: "disableremoteplayback",
  encType: "enctype",
  enterKeyHint: "enterkeyhint",
  fetchPriority: "fetchpriority",
  htmlFor: "for",
  formMethod: "formmethod",
  formAction: "formaction",
  formEncType: "formenctype",
  formNoValidate: "formnovalidate",
  formTarget: "formtarget",
  frameBorder: "frameborder",
  hrefLang: "hreflang",
  httpEquiv: "http-equiv",
  imageSizes: "imagesizes",
  imageSrcSet: "imagesrcset",
  inputMode: "inputmode",
  itemID: "itemid",
  itemProp: "itemprop",
  itemRef: "itemref",
  itemScope: "itemscope",
  itemType: "itemtype",
  keyParams: "keyparams",
  keyType: "keytype",
  marginWidth: "marginwidth",
  marginHeight: "marginheight",
  maxLength: "maxlength",
  mediaGroup: "mediagroup",
  noModule: "nomodule",
  noValidate: "novalidate",
  playsInline: "playsinline",
  radioGroup: "radiogroup",
  readOnly: "readonly",
  referrerPolicy: "referrerpolicy",
  rowSpan: "rowspan",
  spellCheck: "spellcheck",
  srcDoc: "srcdoc",
  srcLang: "srclang",
  srcSet: "srcset",
  tabIndex: "tabindex",
  useMap: "usemap",
  accentHeight: "accent-height",
  alignmentBaseline: "alignment-baseline",
  arabicForm: "arabic-form",
  attributeName: "attributename",
  attributeType: "attributetype",
  autoReverse: "autoreverse",
  baseFrequency: "basefrequency",
  baselineShift: "baseline-shift",
  baseProfile: "baseprofile",
  calcMode: "calcmode",
  capHeight: "cap-height",
  clipPath: "clip-path",
  clipPathUnits: "clippathunits",
  clipRule: "clip-rule",
  colorInterpolation: "color-interpolation",
  colorInterpolationFilters: "color-interpolation-filters",
  colorProfile: "color-profile",
  colorRendering: "color-rendering",
  contentScriptType: "contentscripttype",
  contentStyleType: "contentstyletype",
  diffuseConstant: "diffuseconstant",
  dominantBaseline: "dominant-baseline",
  enableBackground: "enable-background",
  externalResourcesRequired: "externalresourcesrequired",
  fillOpacity: "fill-opacity",
  fillRule: "fill-rule",
  filterRes: "filterres",
  filterUnits: "filterunits",
  floodOpacity: "flood-opacity",
  floodColor: "flood-color",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  glyphName: "glyph-name",
  glyphOrientationHorizontal: "glyph-orientation-horizontal",
  glyphOrientationVertical: "glyph-orientation-vertical",
  gradientTransform: "gradienttransform",
  gradientUnits: "gradientunits",
  horizAdvX: "horiz-adv-x",
  horizOriginX: "horiz-origin-x",
  imageRendering: "image-rendering",
  kernelMatrix: "kernelmatrix",
  kernelUnitLength: "kernelunitlength",
  keyPoints: "keypoints",
  keySplines: "keysplines",
  keyTimes: "keytimes",
  lengthAdjust: "lengthadjust",
  letterSpacing: "letter-spacing",
  lightingColor: "lighting-color",
  limitingConeAngle: "limitingconeangle",
  markerEnd: "marker-end",
  markerHeight: "markerheight",
  markerMid: "marker-mid",
  markerStart: "marker-start",
  markerUnits: "markerunits",
  markerWidth: "markerwidth",
  maskContentUnits: "maskcontentunits",
  maskUnits: "maskunits",
  numOctaves: "numoctaves",
  overlinePosition: "overline-position",
  overlineThickness: "overline-thickness",
  paintOrder: "paint-order",
  panose1: "panose-1",
  pathLength: "pathlength",
  patternContentUnits: "patterncontentunits",
  patternTransform: "patterntransform",
  patternUnits: "patternunits",
  pointerEvents: "pointer-events",
  pointsAtX: "pointsatx",
  pointsAtY: "pointsaty",
  pointsAtZ: "pointsatz",
  preserveAlpha: "preservealpha",
  preserveAspectRatio: "preserveaspectratio",
  primitiveUnits: "primitiveunits",
  refX: "refx",
  refY: "refy",
  renderingIntent: "rendering-intent",
  repeatCount: "repeatcount",
  repeatDur: "repeatdur",
  requiredExtensions: "requiredextensions",
  requiredFeatures: "requiredfeatures",
  shapeRendering: "shape-rendering",
  slot: "slot",
  specularConstant: "specularconstant",
  specularExponent: "specularexponent",
  spreadMethod: "spreadmethod",
  startOffset: "startoffset",
  stdDeviation: "stddeviation",
  stitchTiles: "stitchtiles",
  stopColor: "stop-color",
  stopOpacity: "stop-opacity",
  strikethroughPosition: "strikethrough-position",
  strikethroughThickness: "strikethrough-thickness",
  strokeDasharray: "stroke-dasharray",
  strokeDashoffset: "stroke-dashoffset",
  strokeLinecap: "stroke-linecap",
  strokeLinejoin: "stroke-linejoin",
  strokeMiterlimit: "stroke-miterlimit",
  strokeWidth: "stroke-width",
  strokeOpacity: "stroke-opacity",
  suppressContentEditableWarning: "suppresscontenteditablewarning",
  suppressHydrationWarning: "suppresshydrationwarning",
  surfaceScale: "surfacescale",
  systemLanguage: "systemlanguage",
  tableValues: "tablevalues",
  targetX: "targetx",
  targetY: "targety",
  textAnchor: "text-anchor",
  textDecoration: "text-decoration",
  textLength: "textlength",
  textRendering: "text-rendering",
  transformOrigin: "transform-origin",
  underlinePosition: "underline-position",
  underlineThickness: "underline-thickness",
  unicodeBidi: "unicode-bidi",
  unicodeRange: "unicode-range",
  unitsPerEm: "units-per-em",
  vectorEffect: "vector-effect",
  vertAdvY: "vert-adv-y",
  vertOriginX: "vert-origin-x",
  vertOriginY: "vert-origin-y",
  wordSpacing: "word-spacing",
  writingMode: "writing-mode",
  xChannelSelector: "xchannelselector",
  xHeight: "x-height",
  xlinkActuate: "xlink:actuate",
  xlinkArcrole: "xlink:arcrole",
  xlinkHref: "xlink:href",
  xlinkRole: "xlink:role",
  xlinkShow: "xlink:show",
  xlinkTitle: "xlink:title",
  xlinkType: "xlink:type",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  xmlnsXlink: "xmlns:xlink",
  yChannelSelector: "ychannelselector",
  zoomAndPan: "zoomandpan"
}, O = "[react-output-target]", m = (e) => typeof e == "string" || typeof e == "number" || typeof e == "boolean", d = (e) => e == null, x = (e) => Array.isArray(e), H = (e) => !!e && /^\s*class\s+/.test(e.toString()), $ = (e) => !!e && typeof e == "object" && "_payload" in e, _ = (e) => async ({ children: r, ...n } = {}) => {
  if (!("process" in globalThis) || typeof window < "u")
    throw new Error("`createComponentForServerSideRendering` can only be run on the server");
  let t = "";
  for (const [i, o] of Object.entries(n)) {
    let a = m(o) ? `"${o}"` : void 0;
    if (i === "style" && typeof o == "object" && (a = `"${A(o).replaceAll(`
`, " ")}"`), !a)
      continue;
    const c = L[i] || e.properties[i] || i;
    t += ` ${c}=${a}`;
  }
  let s = "";
  const h = `<${e.tagName}${t} suppressHydrationWarning="true">`, S = console.error;
  try {
    process.env.STENCIL_SSR_DEBUG || (console.error = () => {
    });
    const i = await f(r);
    s = z.renderToString(i);
  } catch (i) {
    if (process.env.STENCIL_SSR_DEBUG) {
      const o = i instanceof Error ? i : new Error("Unknown error");
      console.warn(
        `${O} Failed to serialize light DOM for ${h.slice(0, -1)} />: ${o.message} - this may impact the hydration of the component`
      );
    }
  } finally {
    console.error = S;
  }
  const b = `${h}${s}</${e.tagName}>`, { html: u } = await e.renderToString(b, {
    fullDocument: !1,
    serializeShadowRoot: !0,
    prettyHtml: !0
  });
  if (!u)
    throw new Error("No HTML returned from renderToString");
  const l = u.split(`
`), v = "<!--r.1-->", y = l[1].includes('shadowrootmode="open"');
  let k;
  y && (k = l.slice(2, l.indexOf("  </template>")).join(`
`).trim());
  const { default: w } = await import("html-react-parser"), C = () => w(u, {
    transform(i, o) {
      if ("name" in o && o.name === e.tagName) {
        const a = i.props, c = `${e.tagName}`;
        if (!y) {
          const { children: M, ...T } = a || {}, E = l.slice(1, -1).join(`
`).trim().replace(new RegExp("(?<=>)\\s+(?=<)", "g"), "");
          return /* @__PURE__ */ p.createElement(c, { ...T, suppressHydrationWarning: !0, dangerouslySetInnerHTML: { __html: E } });
        }
        return /* @__PURE__ */ p.createElement(c, { ...a, suppressHydrationWarning: !0 }, /* @__PURE__ */ p.createElement(
          "template",
          {
            shadowrootmode: "open",
            suppressHydrationWarning: !0,
            dangerouslySetInnerHTML: { __html: v + k }
          }
        ), r);
      }
    }
  });
  return /* @__PURE__ */ p.createElement(C, null);
};
async function f(e) {
  return m(e) || d(e) ? e : (x(e) || (e = [e]), Promise.all(
    Array.from(e).map(async (r) => {
      if (m(r) || d(r))
        return r;
      if (x(r))
        return f(r);
      const { type: n, props: t } = r;
      return {
        ...r,
        props: {
          ...t,
          children: await f(t.children)
        },
        type: await g(n, t)
      };
    })
  ));
}
const g = async (e, r) => {
  let n = null;
  if (typeof e == "string")
    return e;
  if (H(e)) {
    const t = new e(r);
    n = t.render ? t.render() : t;
  } else if ($(e)) {
    const t = e._payload, { deault: s } = t._status === -1 ? await t._result() : t._result;
    n = await g(s, r);
  } else typeof e != "object" && (n = await e(r));
  return !d(n) && !m(n) && "type" in n && (n = await g(n.type, r)), n;
};
export {
  _ as createComponentForServerSideRendering
};
